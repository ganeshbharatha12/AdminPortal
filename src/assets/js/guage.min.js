/*
 * AshAlom Gauge Meter.  Version 2.0.0
 * Copyright AshAlom.com  All rights reserved.
 * https://github.com/AshAlom/GaugeMeter <- Deleted!
 * https://github.com/githubsrinath/GaugeMeter <- Backup original.
 *
 * Original created by Dr Ash Alom
 *
 *  Later modified by Michael Wolf (Mictronics)
 * https://github.com/mictronics/GaugeMeter
 *
 * This is a bug fixed and modified version of the AshAlom Gauge Meter.
 * Copyright 2023 SG8 (IB)

 *
 */

!(function ($) {
  $.fn.gaugeMeter = function (t) {
    var defaults = $.extend(
      {
        id: "",
        percent: 0,
        used: null,
        min: null,
        total: null,
        size: 100,
        prepend: "",
        append: "",
        theme: "Red-Gold-Green",
        color: "",
        back: "RGBa(0,0,0,.06)",
        width: 3,
        style: "Full",
        stripe: "0",
        animationstep: 1,
        animate_gauge_colors: false,
        animate_text_colors: false,
        label: "",
        label_color: "Black",
        text: "",
        text_size: 0.22,
        fill: "",
        showvalue: false,
        showminmax: false,
        showcount: false,
      },
      t
    );
    return this.each(function () {
      function getThemeColor(e) {
        var t = "#2C94E0";
        return (
          e || (e = 1e-14),
          "Red-Gold-Green" === option.theme &&
            (e > 0 && (t = "#d90000"),
            e > 10 && (t = "#e32100"),
            e > 20 && (t = "#f35100"),
            e > 30 && (t = "#ff8700"),
            e > 40 && (t = "#ffb800"),
            e > 50 && (t = "#ffd900"),
            e > 60 && (t = "#dcd800"),
            e > 70 && (t = "#a6d900"),
            e > 80 && (t = "#69d900"),
            e > 90 && (t = "#32d900")),
          "Green-Gold-Red" === option.theme &&
            (e > 0 && (t = "#32d900"),
            e > 10 && (t = "#69d900"),
            e > 20 && (t = "#a6d900"),
            e > 30 && (t = "#dcd800"),
            e > 40 && (t = "#ffd900"),
            e > 50 && (t = "#ffb800"),
            e > 60 && (t = "#ff8700"),
            e > 70 && (t = "#f35100"),
            e > 80 && (t = "#e32100"),
            e > 90 && (t = "#d90000")),
          "Green-Red" === option.theme &&
            (e > 0 && (t = "#32d900"),
            e > 10 && (t = "#41c900"),
            e > 20 && (t = "#56b300"),
            e > 30 && (t = "#6f9900"),
            e > 40 && (t = "#8a7b00"),
            e > 50 && (t = "#a75e00"),
            e > 60 && (t = "#c24000"),
            e > 70 && (t = "#db2600"),
            e > 80 && (t = "#f01000"),
            e > 90 && (t = "#ff0000")),
          "Red-Green" === option.theme &&
            (e > 0 && (t = "#ff0000"),
            e > 10 && (t = "#f01000"),
            e > 20 && (t = "#db2600"),
            e > 30 && (t = "#c24000"),
            e > 40 && (t = "#a75e00"),
            e > 50 && (t = "#8a7b00"),
            e > 60 && (t = "#6f9900"),
            e > 70 && (t = "#56b300"),
            e > 80 && (t = "#41c900"),
            e > 90 && (t = "#32d900")),
          "DarkBlue-LightBlue" === option.theme &&
            (e > 0 && (t = "#2c94e0"),
            e > 10 && (t = "#2b96e1"),
            e > 20 && (t = "#2b99e4"),
            e > 30 && (t = "#2a9ce7"),
            e > 40 && (t = "#28a0e9"),
            e > 50 && (t = "#26a4ed"),
            e > 60 && (t = "#25a8f0"),
            e > 70 && (t = "#24acf3"),
            e > 80 && (t = "#23aff5"),
            e > 90 && (t = "#21b2f7")),
          "LightBlue-DarkBlue" === option.theme &&
            (e > 0 && (t = "#21b2f7"),
            e > 10 && (t = "#23aff5"),
            e > 20 && (t = "#24acf3"),
            e > 30 && (t = "#25a8f0"),
            e > 40 && (t = "#26a4ed"),
            e > 50 && (t = "#28a0e9"),
            e > 60 && (t = "#2a9ce7"),
            e > 70 && (t = "#2b99e4"),
            e > 80 && (t = "#2b96e1"),
            e > 90 && (t = "#2c94e0")),
          "DarkRed-LightRed" === option.theme &&
            (e > 0 && (t = "#d90000"),
            e > 10 && (t = "#dc0000"),
            e > 20 && (t = "#e00000"),
            e > 30 && (t = "#e40000"),
            e > 40 && (t = "#ea0000"),
            e > 50 && (t = "#ee0000"),
            e > 60 && (t = "#f30000"),
            e > 70 && (t = "#f90000"),
            e > 80 && (t = "#fc0000"),
            e > 90 && (t = "#ff0000")),
          "LightRed-DarkRed" === option.theme &&
            (e > 0 && (t = "#ff0000"),
            e > 10 && (t = "#fc0000"),
            e > 20 && (t = "#f90000"),
            e > 30 && (t = "#f30000"),
            e > 40 && (t = "#ee0000"),
            e > 50 && (t = "#ea0000"),
            e > 60 && (t = "#e40000"),
            e > 70 && (t = "#e00000"),
            e > 80 && (t = "#dc0000"),
            e > 90 && (t = "#d90000")),
          "DarkGreen-LightGreen" === option.theme &&
            (e > 0 && (t = "#32d900"),
            e > 10 && (t = "#33db00"),
            e > 20 && (t = "#34df00"),
            e > 30 && (t = "#34e200"),
            e > 40 && (t = "#36e700"),
            e > 50 && (t = "#37ec00"),
            e > 60 && (t = "#38f100"),
            e > 70 && (t = "#38f600"),
            e > 80 && (t = "#39f900"),
            e > 90 && (t = "#3afc00")),
          "LightGreen-DarkGreen" === option.theme &&
            (e > 0 && (t = "#3afc00"),
            e > 10 && (t = "#39f900"),
            e > 20 && (t = "#38f600"),
            e > 30 && (t = "#38f100"),
            e > 40 && (t = "#37ec00"),
            e > 50 && (t = "#36e700"),
            e > 60 && (t = "#34e200"),
            e > 70 && (t = "#34df00"),
            e > 80 && (t = "#33db00"),
            e > 90 && (t = "#32d900")),
          "DarkGold-LightGold" === option.theme &&
            (e > 0 && (t = "#ffb800"),
            e > 10 && (t = "#ffba00"),
            e > 20 && (t = "#ffbd00"),
            e > 30 && (t = "#ffc200"),
            e > 40 && (t = "#ffc600"),
            e > 50 && (t = "#ffcb00"),
            e > 60 && (t = "#ffcf00"),
            e > 70 && (t = "#ffd400"),
            e > 80 && (t = "#ffd600"),
            e > 90 && (t = "#ffd900")),
          "LightGold-DarkGold" === option.theme &&
            (e > 0 && (t = "#ffd900"),
            e > 10 && (t = "#ffd600"),
            e > 20 && (t = "#ffd400"),
            e > 30 && (t = "#ffcf00"),
            e > 40 && (t = "#ffcb00"),
            e > 50 && (t = "#ffc600"),
            e > 60 && (t = "#ffc200"),
            e > 70 && (t = "#ffbd00"),
            e > 80 && (t = "#ffba00"),
            e > 90 && (t = "#ffb800")),
          "White" === option.theme && (t = "#fff"),
          "Black" === option.theme && (t = "#000"),
          t
        );
      }
      /* The label below gauge. */
      function createLabel(t, a) {
        if (t.children("b").length === 0) {
          var labelLineHeight = 0;
          if (option.size == 200) {
            labelLineHeight = option.size + 5 * a + 30;
          } else {
            labelLineHeight = option.size + 5 * a;
          }

          $("<b class='orgb'></b>")
            .appendTo(t)
            .html(option.label)
            .css({
              "line-height": labelLineHeight + "px",
              color: option.label_color,
            });

            $("<b class='newb'></b>")
            .appendTo(t)
            .html(option.label)
            .css({
              "line-height": "unset !important",
              color: option.label_color,
            });
        }
        else{

    $(".newb").html(option.label)

}
      }

      /* The labels min and max and used values beside gauge. */
      function createValueLabels(t, a) {
        // console.log(option);
        // console.log(typeof option);
        // console.log(option.total);
        // console.log(option.used);
        var maxm = option.total;
        var coverage = option.used;
        if (t.children("em").length === 0) {
          if (defaults.showminmax === true || option.showminmax === true) {
            $(`<em class='min s${option.size}'></em>`)
              .appendTo(t)
              .html(option.min)
              .css({
                position: "Absolute",
                "text-align": "Center",
                display: "Inline-Block",
                "line-height": option.size + 5 * a + "px",
                color: option.label_color,
              });
            //console.log(maxm);
            $(`<em class='max s${option.size}'></em>`)
              .appendTo(t)
              .html(maxm?.toString())
              .css({
                position: "Absolute",
                "text-align": "Center",
                display: "Inline-Block",
                "line-height": option.size + 5 * a + "px",
                color: option.label_color,
              });
          }
          //    $(`<em class='value s${option.size}'></em>`)
          //     .appendTo(t)
          //     .html("(" + coverage?.toString() + ")")
          //     .css({
          //       position: "Absolute",
          //       "text-align": "Center",
          //       display: "Inline-Block",
          //       "line-height": option.size + 5 * a + "px",
          //       color: option.label_color,
          //     });
        }
      }

      function showPercLabel() {
        $(`#${option.id} + .gaugeMeter SPAN`).css("visibility", "visible");
      }

      function hidePercLabel() {
        $(`#${option.id} + .gaugeMeter SPAN`).css("visibility", "hidden");
      }

      //draws a triangle as value poniter.. we hidden pointer and displaying directly the value
      function drawTriangle(perc) {
        var ratio = Math.PI / (option.total - option.min);
        //console.log(`ratio`)
        //console.log(ratio)
        var angle = (option.used - option.min) * ratio + Math.PI;
        //console.log(`angle`)
        //console.log(angle)
        var radius = 180;
        // first move our cursor to the center of our arcs
        //g.translate(180, 200);
        g.translate(170, 200);
        // then rotate the whole context

        g.rotate(angle);

        // move our cursor to our arc's radius
        g.translate(radius, 0);

        // draw the triangle
        g.fillStyle = "black";
        g.beginPath();
        // this draws the triangle around its center point

        // g.lineTo(5, -5);
        // g.lineTo(5, 5)
        // g.lineTo(-5, 0)
        g.font = "15px Arial";
        g.rotate(-angle);

        let countLabel = "";
        if (defaults.showcount === true || option.showcount === true) {
          countLabel = option.used;
        }

        //
        if (option.size <= 200) {
          g.font = "12px Arial";
          if (perc < 10) g.fillText(countLabel, 10, -90);
          else if (perc < 15) g.fillText(countLabel, 10, -5);
          else if (perc <= 20) g.fillText(countLabel, 5, 0);
          else if (perc <= 30) g.fillText(countLabel, -20, -40);
          else if (perc <= 60) g.fillText(countLabel, -45, -20);
          else if (perc <= 70) g.fillText(countLabel, -5, 0);
          else g.fillText(countLabel, -20, -10);
        } else {
          g.font = "15px Arial";
          if (perc < 10) g.fillText(countLabel, 20, -10);
          else if (perc < 15) g.fillText(countLabel, 10, -5);
          else if (perc <= 20) g.fillText(countLabel, 5, 0);
          else if (perc <= 60) g.fillText(countLabel, 0, 0);
          else if (perc <= 70) g.fillText(countLabel, -5, 0);
          else g.fillText(countLabel, -20, -10);
        }

        g.closePath();
        g.fill();

        // place back our context's transfrom to its default
        g.setTransform(1, 0, 0, 1, 0, 0);
      }
      /* Prepend and append text, the gauge text or percentage value. */
      function createSpanTag(t) {
        var fgcolor = "";
        if (option.animate_text_colors === true) {
          fgcolor = option.fgcolor;
        }
        var child = t.children("span");
        if (child.length !== 0) {
          child.html(r).css({ color: fgcolor });
          return;
        }
        if (option.text_size <= 0.0 || Number.isNaN(option.text_size)) {
          option.text_size = 0.22;
        }
        if (option.text_size > 0.5) {
          option.text_size = 0.5;
        }
        $("<span></span>")
          .appendTo(t)
          .html(r)
          .addClass(`s${option.size}`)
          .css({
            "line-height": option.size + "px",
            "font-size": option.text_size * option.size + "px",
            color: fgcolor,
          });
      }
      /* Get data attributes as options from div tag. Fall back to defaults when not exists. */
      function getDataAttr(t) {
        $.each(dataAttr, function (index, element) {
          if (t.data(element) !== undefined && t.data(element) !== null) {
            option[element] = t.data(element);
          } else {
            option[element] = $(defaults).attr(element);
          }

          if (element === "fill") {
            s = option[element];
          }

          if (
            (element === "size" ||
              element === "width" ||
              element === "animationstep" ||
              element === "stripe") &&
            !Number.isInteger(option[element])
          ) {
            option[element] = parseInt(option[element]);
          }

          if (element === "text_size") {
            option[element] = parseFloat(option[element]);
          }
        });
      }

      /* Set data attributes as options for div tag. . */
      function setDataAttr(t, option) {
        // console.log(option)
        $.each(dataAttr, function (index, element) {
          //console.log(element)
          //console.log(t.data(element))
          if (t.data(element) == undefined || t.data(element) == null) {
            //t.data(element)=option[element]
            //console.log("assign attr")
            $(t).attr("data-" + element, option[element]);
          } else {
            // option[element] = $(defaults).attr(element);
            if (element == "showminmax") {
              $(t).attr("data-" + element, option[element]);
            }

            if (element == "showcount") {
              $(t).attr("data-" + element, option[element]);
            }
          }
        });
      }
      /* Draws the gauge. */
      function drawGauge(a) {
        if (M < 0) M = 0;
        if (M > 100) M = 100;
        var lw = option.width < 1 || isNaN(option.width) ? option.size / 20 : option.width;
        g.clearRect(0, 0, b.width, b.height);
        g.beginPath();
        g.arc(m, v, x, G, k, !1);
        if (s) {
          g.fillStyle = option.fill;
          g.fill();
        }
        g.lineWidth = lw;
        g.strokeStyle = option.back;
        option.stripe > parseInt(0) ? g.setLineDash([option.stripe], 1) : (g.lineCap = "round");
        g.stroke();
        g.beginPath();
        g.arc(m, v, x, -I, P * a - I, !1);
        g.lineWidth = lw;
        g.strokeStyle = option.fgcolor;
        g.stroke();

        c > M &&
          ((M += z),
          requestAnimationFrame(function () {
            drawGauge(Math.min(M, c) / 100);
          }, p));
        if (c <= M) {
          requestAnimationFrame(function () {
            drawTriangle(c);
            showPercLabel();
          }, p);
        }
        // console.log(c);
        // console.log(M);
        // console.log(m);
        // console.log(v);
        // console.log(x);
        // console.log(G);
        // console.log(k);
        // console.log(-I);
        // console.log(a);
        // console.log(p * a - I);
        // g.save();

        // //g.translate(m,v);
        // g.translate(180, 200);
        // g.rotate(M*Math.PI/180);
        // g.font = "20px Arial";
        // // g.fillText(countLabel, M, v);
        // g.fillText(M, -M, v);

        // g.restore();
      }

      function roundNumber(num, scale) {
        if (!("" + num).includes("e")) {
          return +(Math.round(num + "e+" + scale) + "e-" + scale);
        } else {
          var arr = ("" + num).split("e");
          var sig = "";
          if (+arr[1] + scale > 0) {
            sig = "+";
          }
          return +(Math.round(+arr[0] + "e" + sig + (+arr[1] + scale)) + "e-" + scale);
        }
      }

      $(this).attr("data-id", $(this).attr("id"));
      var r,
        dataAttr = [
          "percent",
          "used",
          "min",
          "total",
          "size",
          "prepend",
          "append",
          "theme",
          "color",
          "back",
          "width",
          "style",
          "stripe",
          "animationstep",
          "animate_gauge_colors",
          "animate_text_colors",
          "label",
          "label_color",
          "text",
          "text_size",
          "fill",
          "showvalue",
          "showminmax",
          "showcount",
        ],
        option = {},
        c = 0,
        p = $(this),
        s = false;
      p.addClass("gaugeMeter");
      getDataAttr(p);
      setDataAttr(p, option);

      // console.log(option);

      if (Number.isInteger(option.used) && Number.isInteger(option.total)) {
        var u = option.used;
        var t = option.total;
        if (Number.isInteger(option.min)) {
          if (option.min < 0) {
            t -= option.min;
            u -= option.min;
          }
        }
        c = u / (t / 100);
      } else {
        if (Number.isInteger(option.percent) && option.percent!=0) {

          c = option.percent;

       }
       else {
 if(Number.isFinite(option.used) && Number.isFinite(option.total)){

    var u = option.used;

       var t = option.total;

        c = u / (t / 100);
         }else{
           c = parseInt(defaults.percent);}
}
      }
      hidePercLabel();
      if (c < 0) c = 0;
      if (c > 100) c = 100;

      if (Number.isInteger(c)) {
      } else {
        //c=parseFloat(c).toFixed(2);
        c = roundNumber(c, 2);
      }

      if (option.text !== "" && option.text !== null && option.text !== undefined) {
        if (option.append !== "" && option.append !== null && option.append !== undefined) {
          r = option.text + "<u>" + option.append + "</u>";
        } else {
          r = option.text;
        }
        if (option.prepend !== "" && option.prepend !== null && option.prepend !== undefined) {
          r = "<s>" + option.prepend + "</s>" + r;
        }
      } else {
        if (defaults.showvalue === true || option.showvalue === true) {
          r = option.used;
        } else {
          r = c.toString();
        }
        if (option.prepend !== "" && option.prepend !== null && option.prepend !== undefined) {
          r = "<s>" + option.prepend + "</s>" + r;
        }

        if (option.append !== "" && option.append !== null && option.append !== undefined) {
          r = r + "<u>" + option.append + "</u>";
        }
      }

      option.fgcolor = getThemeColor(c);
      if (option.color !== "" && option.color !== null && option.color !== undefined) {
        option.fgcolor = option.color;
      }

      if (option.animate_gauge_colors === true) {
        option.fgcolor = getThemeColor(c);
      }
      createSpanTag(p);

      // if (option.style !== "" && option.style !== null && option.style !== undefined) {
      //   createLabel(p, option.size / 13);
      // }
      createValueLabels(p);

      $(this).width(option.size + "px");

      var b = $("<canvas></canvas>").attr({ width: option.size, height: option.size }).get(0),
        g = b.getContext("2d"),
        m = b.width / 2,
        v = b.height / 2,
        _ = 360 * option.percent,
        // x = (_ * (Math.PI / 180), b.width / 2.5),
        x = (_ * (Math.PI / 180), b.width / 3),
        k = 2.3 * Math.PI,
        G = 0,
        M = 0 === option.animationstep ? c : 0,
        z = Math.max(option.animationstep, 0),
        P = 2 * Math.PI,
        I = Math.PI / 2,
        R = option.style;
      var canvastitle = `${c}${option.append}(${option.used}) ${option.label} out of ${option.total}`;
      b.attributes["title"] = canvastitle;
      var child = $(this).children("canvas");
      if (child.length !== 0) {
        /* Replace existing canvas when new percentage was written. */
        child.replaceWith(b);
      } else {
        /* Initially create canvas. */
        $(b).appendTo($(this));
        if (option.style !== "" && option.style !== null && option.style !== undefined) {
          createLabel(p, option.size / 13);
        }
      }

      if ("Semi" === R) {
        k = 2 * Math.PI;
        G = 3.13;
        P = 1 * Math.PI;
        I = Math.PI / 0.996;
      }
      if ("Arch" === R) {
        k = 2.195 * Math.PI;
        (G = 1), (G = 655.99999);
        P = 1.4 * Math.PI;
        I = Math.PI / 0.8335;
      }
      drawGauge(M / 100);
    });
  };

  $.fn.updateGaugeMeter = function (update) {
    // console.log(`updating gauge(${update.id}).. ${update.used}/${update.total}`);
    var defaults = $.extend(
      {
        id: "",
        percent: 0,
        used: null,
        min: null,
        total: null,
        size: 100,
        prepend: "",
        append: "",
        theme: "Red-Gold-Green",
        color: "",
        back: "RGBa(0,0,0,.06)",
        width: 3,
        style: "Full",
        stripe: "0",
        animationstep: 1,
        animate_gauge_colors: false,
        animate_text_colors: false,
        label: "",
        label_color: "Black",
        text: "",
        text_size: 0.22,
        fill: "",
        showvalue: false,
        showminmax: false,
        showcount: false,
      },
      update
    );
    return this.each(function () {
      function getThemeColor(e) {
        var t = "#2C94E0";
        return (
          e || (e = 1e-14),
          "Red-Gold-Green" === option.theme &&
            (e > 0 && (t = "#d90000"),
            e > 10 && (t = "#e32100"),
            e > 20 && (t = "#f35100"),
            e > 30 && (t = "#ff8700"),
            e > 40 && (t = "#ffb800"),
            e > 50 && (t = "#ffd900"),
            e > 60 && (t = "#dcd800"),
            e > 70 && (t = "#a6d900"),
            e > 80 && (t = "#69d900"),
            e > 90 && (t = "#32d900")),
          "Green-Gold-Red" === option.theme &&
            (e > 0 && (t = "#32d900"),
            e > 10 && (t = "#69d900"),
            e > 20 && (t = "#a6d900"),
            e > 30 && (t = "#dcd800"),
            e > 40 && (t = "#ffd900"),
            e > 50 && (t = "#ffb800"),
            e > 60 && (t = "#ff8700"),
            e > 70 && (t = "#f35100"),
            e > 80 && (t = "#e32100"),
            e > 90 && (t = "#d90000")),
          "Green-Red" === option.theme &&
            (e > 0 && (t = "#32d900"),
            e > 10 && (t = "#41c900"),
            e > 20 && (t = "#56b300"),
            e > 30 && (t = "#6f9900"),
            e > 40 && (t = "#8a7b00"),
            e > 50 && (t = "#a75e00"),
            e > 60 && (t = "#c24000"),
            e > 70 && (t = "#db2600"),
            e > 80 && (t = "#f01000"),
            e > 90 && (t = "#ff0000")),
          "Red-Green" === option.theme &&
            (e > 0 && (t = "#ff0000"),
            e > 10 && (t = "#f01000"),
            e > 20 && (t = "#db2600"),
            e > 30 && (t = "#c24000"),
            e > 40 && (t = "#a75e00"),
            e > 50 && (t = "#8a7b00"),
            e > 60 && (t = "#6f9900"),
            e > 70 && (t = "#56b300"),
            e > 80 && (t = "#41c900"),
            e > 90 && (t = "#32d900")),
          "DarkBlue-LightBlue" === option.theme &&
            (e > 0 && (t = "#2c94e0"),
            e > 10 && (t = "#2b96e1"),
            e > 20 && (t = "#2b99e4"),
            e > 30 && (t = "#2a9ce7"),
            e > 40 && (t = "#28a0e9"),
            e > 50 && (t = "#26a4ed"),
            e > 60 && (t = "#25a8f0"),
            e > 70 && (t = "#24acf3"),
            e > 80 && (t = "#23aff5"),
            e > 90 && (t = "#21b2f7")),
          "LightBlue-DarkBlue" === option.theme &&
            (e > 0 && (t = "#21b2f7"),
            e > 10 && (t = "#23aff5"),
            e > 20 && (t = "#24acf3"),
            e > 30 && (t = "#25a8f0"),
            e > 40 && (t = "#26a4ed"),
            e > 50 && (t = "#28a0e9"),
            e > 60 && (t = "#2a9ce7"),
            e > 70 && (t = "#2b99e4"),
            e > 80 && (t = "#2b96e1"),
            e > 90 && (t = "#2c94e0")),
          "DarkRed-LightRed" === option.theme &&
            (e > 0 && (t = "#d90000"),
            e > 10 && (t = "#dc0000"),
            e > 20 && (t = "#e00000"),
            e > 30 && (t = "#e40000"),
            e > 40 && (t = "#ea0000"),
            e > 50 && (t = "#ee0000"),
            e > 60 && (t = "#f30000"),
            e > 70 && (t = "#f90000"),
            e > 80 && (t = "#fc0000"),
            e > 90 && (t = "#ff0000")),
          "LightRed-DarkRed" === option.theme &&
            (e > 0 && (t = "#ff0000"),
            e > 10 && (t = "#fc0000"),
            e > 20 && (t = "#f90000"),
            e > 30 && (t = "#f30000"),
            e > 40 && (t = "#ee0000"),
            e > 50 && (t = "#ea0000"),
            e > 60 && (t = "#e40000"),
            e > 70 && (t = "#e00000"),
            e > 80 && (t = "#dc0000"),
            e > 90 && (t = "#d90000")),
          "DarkGreen-LightGreen" === option.theme &&
            (e > 0 && (t = "#32d900"),
            e > 10 && (t = "#33db00"),
            e > 20 && (t = "#34df00"),
            e > 30 && (t = "#34e200"),
            e > 40 && (t = "#36e700"),
            e > 50 && (t = "#37ec00"),
            e > 60 && (t = "#38f100"),
            e > 70 && (t = "#38f600"),
            e > 80 && (t = "#39f900"),
            e > 90 && (t = "#3afc00")),
          "LightGreen-DarkGreen" === option.theme &&
            (e > 0 && (t = "#3afc00"),
            e > 10 && (t = "#39f900"),
            e > 20 && (t = "#38f600"),
            e > 30 && (t = "#38f100"),
            e > 40 && (t = "#37ec00"),
            e > 50 && (t = "#36e700"),
            e > 60 && (t = "#34e200"),
            e > 70 && (t = "#34df00"),
            e > 80 && (t = "#33db00"),
            e > 90 && (t = "#32d900")),
          "DarkGold-LightGold" === option.theme &&
            (e > 0 && (t = "#ffb800"),
            e > 10 && (t = "#ffba00"),
            e > 20 && (t = "#ffbd00"),
            e > 30 && (t = "#ffc200"),
            e > 40 && (t = "#ffc600"),
            e > 50 && (t = "#ffcb00"),
            e > 60 && (t = "#ffcf00"),
            e > 70 && (t = "#ffd400"),
            e > 80 && (t = "#ffd600"),
            e > 90 && (t = "#ffd900")),
          "LightGold-DarkGold" === option.theme &&
            (e > 0 && (t = "#ffd900"),
            e > 10 && (t = "#ffd600"),
            e > 20 && (t = "#ffd400"),
            e > 30 && (t = "#ffcf00"),
            e > 40 && (t = "#ffcb00"),
            e > 50 && (t = "#ffc600"),
            e > 60 && (t = "#ffc200"),
            e > 70 && (t = "#ffbd00"),
            e > 80 && (t = "#ffba00"),
            e > 90 && (t = "#ffb800")),
          "White" === option.theme && (t = "#fff"),
          "Black" === option.theme && (t = "#000"),
          t
        );
      }
      /* The label below gauge. */
      function createLabel(t, a) {
        if (t.children("b").length === 0) {
          var labelLineHeight = 0;
          if (option.size == 200) {
            labelLineHeight = option.size + 5 * a + 30;
          } else {
            labelLineHeight = option.size + 5 * a;
          }

          $("<b></b>")
            .appendTo(t)
            .html(option.label)
            .css({
              "line-height": labelLineHeight + "px",
              color: option.label_color,
            });
        }
        else{

          $(".newb").html(option.label)

          }
      }

      /* The labels min and max and used values beside gauge. */
      function createValueLabels(t, a) {
        // console.log(option);

        var maxm = option.total;
        var coverage = option.used;
        if (t.children("em").length === 0) {
          // console.log(`no em`);
          if (defaults.showminmax === true || option.showminmax === true) {
            $(`<em class='min s${option.size}'></em>`)
              .appendTo(t)
              .html("0")
              .css({
                position: "Absolute",
                "text-align": "Center",
                display: "Inline-Block",
                "line-height": option.size + 5 * a + "px",
                color: option.label_color,
              });
            //console.log(maxm);
            $(`<em class='max s${option.size}'></em>`)
              .appendTo(t)
              .html(maxm?.toString())
              .css({
                position: "Absolute",
                "text-align": "Center",
                display: "Inline-Block",
                "line-height": option.size + 5 * a + "px",
                color: option.label_color,
              });
          }

          //$(`<em class='value s${option.size}'></em>`)
          //     .appendTo(t)
          //     .html("(" + coverage?.toString() + ")")
          //     .css({
          //       position: "Absolute",
          //       "text-align": "Center",
          //       display: "Inline-Block",
          //       "line-height": option.size + 5 * a + "px",
          //       color: option.label_color,
          //     });
        } else {
          //updating
          //console.log(`em exists`);
          if (defaults.showminmax === true || option.showminmax === true) {
            // console.log(`setting em`);
            // console.log($(`#${option.id} > em.max`));
            // console.log(option.id);
            $(`#${option.id} > em.min`).each(function (i, min) {
              // console.log(min);
              min.innerHTML = option.min;
              $(min).html(option.min);
            });
            $(`#${option.id} > em.max`).each(function (i, max) {
              // console.log(max);
              max.innerHTML = option.total;
              $(max).html(option.total);
            });
          }
        }
      }

      function showPercLabel() {
        $(`#${option.id} > .gaugeMeter SPAN`).css("visibility", "visible");
      }

      function hidePercLabel() {
        $(`#${option.id} > .gaugeMeter SPAN`).css("visibility", "hidden");
      }

      //draws a triangle as value poniter.. we hidden pointer and displaying directly the value
      function drawTriangle(perc, lw) {
        var ratio = Math.PI / (option.total - option.min);
        //console.log(`ratio`)
        //console.log(ratio)
        var angle = (option.used - option.min) * ratio + Math.PI;
       // console.log(`angle`);
       // console.log(angle);
       // console.log(`degrees1: ${(angle * 180) / Math.PI}`);
        //  console.log(`degrees: ${angle * 0.0174532925}`)

       // console.log(perc);
        //console.log(a)
       // console.log(lw);
        const [x0, y0] = pointsOnCircle({ radius: x + 2, angle: angle, cx: m, cy: v }); //+lw
        //console.log(x0, y0);
        // g.fillText(countLabel, x0,y0);

        var extraLength = lw + 0.25;



        var text = option.used;
        if (option.used.toString().length == 2) {
          extraLength = lw + 0.5;
        } else if (option.used.toString().length == 3) {
          extraLength = lw / 2;
        } else {
          extraLength = lw + 1.5;
        }


        let countLabel = "";
        if (defaults.showcount === true || option.showcount === true) {
          countLabel = option.used;
          text=countLabel
        }else{
          text=""
        }

        if (perc > 75) {
          text = " " + text;
          extraLength = lw / 2;
        } else {
          text = text + " ";
        }

        const currentAngle = G + (perc / 100) * (k - G);
       // console.log(currentAngle);
        const [x00, y00] = pointsOnCircle({ radius: x + extraLength, angle: angle, cx: m, cy: v }); //+lw
       // console.log(x00, y00);
      //  console.log("----text---"+text)
        g.fillText(text, x00, y00);
        var radius = 180;
        // first move our cursor to the center of our arcs
        //g.translate(180, 200);
        g.translate(170, 200);
        // then rotate the whole context

        g.rotate(angle);

        // move our cursor to our arc's radius
        g.translate(radius, 0);

        // draw the triangle
        g.fillStyle = "black";
        g.beginPath();
        // this draws the triangle around its center point

        // g.lineTo(5, -5);
        // g.lineTo(5, 5)
        // g.lineTo(-5, 0)

        g.rotate(-angle);

        //x --> negative is left
        //y--> negative is top

        // console.log(`radius: ${radius}`)

        //         x = radius *  sin(angle)
        // y = radius * -cos(angle)

        // * 0.0174532925 //radians


        var oldCal = false;
        if (oldCal) {
          if (option.size <= 200) {
            g.font = "11px Arial";
            if (perc <= 3) g.fillText(countLabel, 29.82, -90); //x-90 y-90 100-70, 100-x=-90
            else if (perc <= 7) g.fillText(countLabel, 17.5, -85);
            else if (perc <= 10) g.fillText(countLabel, 15, -75);
            else if (perc <= 15) g.fillText(countLabel, 10, -65);
            else if (perc <= 20) g.fillText(countLabel, -10, -40);
            else if (perc <= 30) g.fillText(countLabel, -25, -25);
            else if (perc <= 45) g.fillText(countLabel, -50, -5);
            else if (perc < 50) g.fillText(countLabel, -70, -5);
            else if (perc == 50) g.fillText(countLabel, -77.5, -7.5);
            else if (perc <= 55) g.fillText(countLabel, -87.5, -7.5);
            else if (perc <= 60) g.fillText(countLabel, -110, -12.5);
            else if (perc < 65) g.fillText(countLabel, -105, -10);
            else if (perc < 70) g.fillText(countLabel, -122.5, -25);
            else if (perc <= 75) g.fillText(countLabel, -132.5, -35);
            else if (perc <= 80) g.fillText(countLabel, -142.5, -40);
            else if (perc <= 85) g.fillText(countLabel, -152.5, -55);
            else if (perc <= 90) g.fillText(countLabel, -160, -65);
            else if (perc <= 95) g.fillText(countLabel, -162.5, -77.5);
            else if (perc <= 99) g.fillText(countLabel, -165, -92.5);
            else g.fillText(countLabel, -170.175, -90); //-160, -100
          } else {
            g.font = "15px Arial";
            if (perc < 10) g.fillText(countLabel, 20, -10);
            else if (perc < 15) g.fillText(countLabel, 10, -5);
            else if (perc <= 20) g.fillText(countLabel, 5, 0);
            else if (perc <= 60) g.fillText(countLabel, 0, 0);
            else if (perc <= 70) g.fillText(countLabel, -5, 0);
            else g.fillText(countLabel, -20, -10);
          }
        }

        g.closePath();
        g.fill();

        // place back our context's transfrom to its default
        g.setTransform(1, 0, 0, 1, 0, 0);
        showPercLabel();
      }
      /* Prepend and append text, the gauge text or percentage value. */
      function createSpanTag(t) {
        var fgcolor = "";
        if (option.animate_text_colors === true) {
          fgcolor = option.fgcolor;
        }
        var child = t.children("span");
        if (child.length !== 0) {
          child.html(r).css({ color: fgcolor });
          return;
        }
        if (option.text_size <= 0.0 || Number.isNaN(option.text_size)) {
          option.text_size = 0.22;
        }
        if (option.text_size > 0.5) {
          option.text_size = 0.5;
        }
        $("<span></span>")
          .appendTo(t)
          .html(r)
          .addClass(`s${option.size}`)
          .css({
            "line-height": option.size + "px",
            "font-size": option.text_size * option.size + "px",
            color: fgcolor,
          });
      }
      /* Get data attributes as options from div tag. Fall back to defaults when not exists. */
      function getDataAttr(t) {
        $.each(dataAttr, function (index, element) {
          if (t.data(element) !== undefined && t.data(element) !== null) {
            option[element] = t.data(element);
          } else {
            option[element] = $(defaults).attr(element);
          }

          if (element === "fill") {
            s = option[element];
          }

          if (
            (element === "size" ||
              element === "width" ||
              element === "animationstep" ||
              element === "stripe") &&
            !Number.isInteger(option[element])
          ) {
            option[element] = parseInt(option[element]);
          }

          if (element === "text_size") {
            option[element] = parseFloat(option[element]);
          }
        });
      }
      function pointsOnCircle({ radius, angle, cx, cy }) {
        // angle = angle * ( Math.PI / 180 ); // Convert from Degrees to Radians
        const x = cx + radius * Math.cos(angle);
        const y = cy + radius * Math.sin(angle);
        // const x = cx + radius * Math.sin(angle)+90;
        // const y = - radius * Math.cos(angle)+cy+90;
        return [x, y];
      }

      /* Set data attributes as options for div tag. . */
      function updateDataAttr(t, option) {
        $.each(dataAttr, function (index, element) {
          //console.log(element)
          // console.log(t.data(element))
          if (t.data(element) == undefined || t.data(element) == null) {
            //t.data(element)=option[element]
            //console.log("assign attr")
            $(t).attr("data-" + element, option[element]);
          } else {
            if (element == "min" || element == "total" || element == "used") {
              $(t).attr("data-" + element, option[element]);
            }
            // option[element] = $(defaults).attr(element);
          }
        });
        $;
      }
      /* Draws the gauge. */
      function drawGauge(a) {
        if (M < 0) M = 0;
        if (M > 100) M = 100;
        var lw = option.width < 1 || isNaN(option.width) ? option.size / 20 : option.width;

        g.clearRect(0, 0, b.width, b.height);
        g.beginPath();
        g.arc(m, v, x, G, k, !1);
        if (s) {
          g.fillStyle = option.fill;
          g.fill();
        }
        g.lineWidth = lw;
        g.strokeStyle = option.back;
        option.stripe > parseInt(0) ? g.setLineDash([option.stripe], 1) : (g.lineCap = "round");
        g.stroke();
        g.beginPath();
        g.arc(m, v, x, -I, P * a - I, !1);
        g.lineWidth = lw;
        g.strokeStyle = option.fgcolor;
        g.stroke();

        c > M &&
          ((M += z),
          requestAnimationFrame(function () {
            drawGauge(Math.min(M, c) / 100);
          }, p));
        if (c <= M) {
          requestAnimationFrame(function () {
            drawTriangle(c, lw);
          }, p);
        }

        // console.log(a);
        // console.log(p * a - I);
        // g.save();

        // //g.translate(m,v);
        // g.translate(180, 200);
        // g.rotate(M*Math.PI/180);
        // g.font = "20px Arial";
        // // g.fillText(countLabel, M, v);
        // g.fillText(M, -M, v);

        // g.restore();
      }

      function roundNumber(num, scale) {
        if (!("" + num).includes("e")) {
          return +(Math.round(num + "e+" + scale) + "e-" + scale);
        } else {
          var arr = ("" + num).split("e");
          var sig = "";
          if (+arr[1] + scale > 0) {
            sig = "+";
          }
          return +(Math.round(+arr[0] + "e" + sig + (+arr[1] + scale)) + "e-" + scale);
        }
      }

      $(this).attr("data-id", $(this).attr("id"));
      var r,
        dataAttr = [
          "percent",
          "used",
          "min",
          "total",
          "size",
          "prepend",
          "append",
          "theme",
          "color",
          "back",
          "width",
          "style",
          "stripe",
          "animationstep",
          "animate_gauge_colors",
          "animate_text_colors",
          "label",
          "label_color",
          "text",
          "text_size",
          "fill",
          "showvalue",
          "showminmax",
          "showcount",
        ],
        option = {},
        c = 0,
        p = $(this),
        s = false;
      // p.addClass("gaugeMeter");
      //  console.log(update);
      getDataAttr(p);
      option.id = $(this).attr("id");
      //console.log("before update");
      //console.log(option)

      option.min = update.min ?? option.min;
      option.total = update.total ?? option.total;
      option.used = update.used ?? option.used;
      option.label = update.label ?? option.label;
      updateDataAttr(p, option);
      //console.log("after update");
      //console.log(option)

      if (Number.isInteger(option.used) && Number.isInteger(option.total)) {
        var u = option.used;
        var t = option.total;
        if (Number.isInteger(option.min)) {
          if (option.min < 0) {
            t -= option.min;
            u -= option.min;
          }
        }
        c = u / (t / 100);
      } else {
        // if (Number.isInteger(option.percent)) {
        //   c = option.percent;
        // } else {
        //   c = parseInt(defaults.percent);
        // }
        if (Number.isInteger(option.percent) && option.percent!=0) {

          c = option.percent;

       }
       else {
 if(Number.isFinite(option.used) && Number.isFinite(option.total)){

    var u = option.used;

       var t = option.total;

        c = u / (t / 100);
         }else{
           c = parseInt(defaults.percent);}
}



      }
      hidePercLabel();
      if (c < 0) c = 0;
      if (c > 100) c = 100;

      if (Number.isInteger(c)) {
      } else {
        //c=parseFloat(c).toFixed(2);
        c = roundNumber(c, 2);
      }

      if (option.text !== "" && option.text !== null && option.text !== undefined) {
        if (option.append !== "" && option.append !== null && option.append !== undefined) {
          r = option.text + "<u>" + option.append + "</u>";
        } else {
          r = option.text;
        }
        if (option.prepend !== "" && option.prepend !== null && option.prepend !== undefined) {
          r = "<s>" + option.prepend + "</s>" + r;
        }
      } else {
        if (defaults.showvalue === true || option.showvalue === true) {
          r = option.used;
        } else {
          r = c.toString();
        }
        if (option.prepend !== "" && option.prepend !== null && option.prepend !== undefined) {
          r = "<s>" + option.prepend + "</s>" + r;
        }

        if (option.append !== "" && option.append !== null && option.append !== undefined) {
          r = r + "<u>" + option.append + "</u>";
        }

      }

      if(r=="NaN<u>"+ option.append +"</u>" || r=="NaN"){r="--"}

      option.fgcolor = getThemeColor(c);
      if (option.color !== "" && option.color !== null && option.color !== undefined) {
        option.fgcolor = option.color;
      }

      if (option.animate_gauge_colors === true) {
        option.fgcolor = getThemeColor(c);
      }
      createSpanTag(p);


      createValueLabels(p);

      $(this).width(option.size + 50 + "px");

      var b = $("<canvas></canvas>")
          .attr({ width: option.size, height: option.size })
          .css({
            padding: 0,
            "box-sizing": "border-box",

            // border: "2px solid #428bca",
            "z-index": 100,

            //padding: "10 50px",
            overflow: "visible",
          })
          .get(0),
        g = b.getContext("2d"),
        m = b.width / 2,
        v = b.height / 2,
        _ = 360 * option.percent;
      var x;
      if (option.size == 200) {
        x = (_ * (Math.PI / 180), b.width / 2.85);
      } else {
        x = (_ * (Math.PI / 180), b.width / 2.5);
      }

      var k = 2.3 * Math.PI,
        G = 0,
        M = 0 === option.animationstep ? c : 0,
        z = Math.max(option.animationstep, 0),
        P = 2 * Math.PI,
        I = Math.PI / 2,
        R = option.style;
      var canvastitle = `${c}${option.append}(${option.used}) ${option.label} out of ${option.total}`;
      b.attributes["title"] = canvastitle;
      var child = $(this).children("canvas");
      if (child.length !== 0) {
        /* Replace existing canvas when new percentage was written. */
        child.replaceWith(b);
      } else {
        /* Initially create canvas. */
        $(b).appendTo($(this));
        if (option.style !== "" && option.style !== null && option.style !== undefined) {
          createLabel(p, option.size / 13);
        }
      }

      if ("Semi" === R) {
        k = 2 * Math.PI;
        G = 3.13;
        P = 1 * Math.PI;
        I = Math.PI / 0.996;
      }
      if ("Arch" === R) {
        k = 2.195 * Math.PI;
        (G = 1), (G = 655.99999);
        P = 1.4 * Math.PI;
        I = Math.PI / 0.8335;
      }
      drawGauge(M / 100);
    });
  };
})(jQuery);
